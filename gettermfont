#!/bin/bash
term=$(ps -p $(xdotool getactivewindow getwindowpid) o cmd h | sed -e 's/.*\///')
trim() {
    set -f
    # shellcheck disable=2048,2086
    set -- $*
    printf '%s\n' "${*//[[:space:]]/}"
    set +f
}
trim_quotes() {
    trim_output="${1//\'}"
    trim_output="${trim_output//\"}"
    printf "%s" "$trim_output"
}
case $term in
    "alacritty"*)
        shopt -s nullglob
        confs=({$XDG_CONFIG_HOME,$HOME}/{alacritty,}/{.,}alacritty.ym?)
        shopt -u nullglob

        [[ -f "${confs[0]}" ]] || return

        font="$(awk '/normal:/ {while (!/family:/ || /#/)
                        {if (!getline) {exit}} print; exit}' "${confs[0]}")"
        font="${font/*family:}"
        font="${font/$'\n'*}"
        font="${font/\#*}"
    ;;

    "Apple_Terminal")
        font="$(osascript <<END
                        tell application "Terminal" to font name of window frontmost
END
)"
    ;;

    "iTerm2")
        # Unfortunately the profile name is not unique, but it seems to be the only thing
        # that identifies an active profile. There is the "id of current session of current win-
        # dow" though, but that does not match to a guid in the plist.
        # So, be warned, collisions may occur!
        # See: https://groups.google.com/forum/#!topic/iterm2-discuss/0tO3xZ4Zlwg
        local current_profile_name profiles_count profile_name diff_font

        current_profile_name="$(osascript <<END
                                tell application "iTerm2" to profile name \
                                of current session of current window
END
)"

        # Warning: Dynamic profiles are not taken into account here!
        # https://www.iterm2.com/documentation-dynamic-profiles.html
        font_file="${HOME}/Library/Preferences/com.googlecode.iterm2.plist"

        # Count Guids in "New Bookmarks"; they should be unique
        profiles_count="$(PlistBuddy -c "Print ':New Bookmarks:'" "$font_file" | \
                            grep -w -c "Guid")"

        for ((i=0; i<profiles_count; i++)); do
            profile_name="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Name:'" "$font_file")"

            if [[ "$profile_name" == "$current_profile_name" ]]; then
                # "Normal Font"
                font="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Normal Font:'" \
                                "$font_file")"

                # Font for non-ascii characters
                # Only check for a different non-ascii font, if the user checked
                # the "use a different font for non-ascii text" switch.
                diff_font="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Use Non-ASCII Font:'" \
                                "$font_file")"

                if [[ "$diff_font" == "true" ]]; then
                    non_ascii="$(PlistBuddy -c "Print ':New Bookmarks:${i}:Non Ascii Font:'" \
                                    "$font_file")"

                    [[ "$font" != "$non_ascii" ]] && \
                        font="$font (normal) / $non_ascii (non-ascii)"
                fi
            fi
        done
    ;;

    "deepin-terminal"*)
        font="$(awk -F '=' '/font=/ {a=$2} /font_size/ {b=$2} END {print a,b}' \
                        "$HOME/.config/deepin/deepin-terminal/config.conf")"
    ;;

    "GNUstep_Terminal")
            font="$(awk -F '>|<' '/>TerminalFont</ {getline; f=$3}
                        />TerminalFontSize</ {getline; s=$3} END {print f,s}' \
                        "${HOME}/GNUstep/Defaults/Terminal.plist")"
    ;;

    "Hyper"*)
        font="$(awk -F':|,' '/fontFamily/ {print $2; exit}' "${HOME}/.hyper.js")"
        font="$(trim_quotes "$font")"
    ;;

    "kitty"*)
        kitty_config="$(kitty --debug-config)"
        [[ "$kitty_config" != *font_family* ]] && return

        font="$(awk '/^font_family|^font_size/ {$1="";gsub("^ *","",$0);print $0}' \
                        <<< "$kitty_config")"
    ;;

    "konsole" | "yakuake")
        # Get Process ID of current konsole window / tab
        child="$(get_ppid "$$")"

        QT_BINDIR="$(qtpaths --binaries-dir)" && PATH+=":$QT_BINDIR"

        IFS=$'\n' read -d "" -ra konsole_instances \
            <<< "$(qdbus | awk '/org.kde.'"$term"'/ {print $1}')"

        for i in "${konsole_instances[@]}"; do
            IFS=$'\n' read -d "" -ra konsole_sessions <<< "$(qdbus "$i" | grep -F '/Sessions/')"

            for session in "${konsole_sessions[@]}"; do
                if ((child == "$(qdbus "$i" "$session" processId)")); then
                    profile="$(qdbus "$i" "$session" environment |\
                                awk -F '=' '/KONSOLE_PROFILE_NAME/ {print $2}')"
                    [[ $profile ]] || profile="$(qdbus "$i" "$session" profile)"
                    break
                fi
            done
            [[ $profile ]] && break
        done

        [[ $profile ]] || return

        # We could have two profile files for the same profile name, take first match
        profile_filename="$(grep -l "Name=${profile}" "$HOME"/.local/share/konsole/*.profile)"
        profile_filename="${profile_filename/$'\n'*}"

        [[ $profile_filename ]] && \
            font="$(awk -F '=|,' '/Font=/ {print $2,$3}' "$profile_filename")"
    ;;

    "lxterminal"*)
        font="$(awk -F '=' '/fontname=/ {print $2; exit}' \
                        "$HOME/.config/lxterminal/lxterminal.conf")"
    ;;

    "mate-terminal")
        # To get the actual config we have to create a temporarily file with the
        # --save-config option.
        mateterm_config="/tmp/mateterm.cfg"

        # Ensure /tmp exists and we do not overwrite anything.
        if [[ -d "/tmp" && ! -f "$mateterm_config" ]]; then
            mate-terminal --save-config="$mateterm_config"

            role="$(xprop -id "${WINDOWID}" WM_WINDOW_ROLE)"
            role="${role##* }"
            role="${role//\"}"

            profile="$(awk -F '=' -v r="$role" \
                                '$0~r {
                                        getline;
                                        if(/Maximized/) getline;
                                        if(/Fullscreen/) getline;
                                        id=$2"]"
                                        } $0~id {if(id) {getline; print $2; exit}}' \
                        "$mateterm_config")"

            rm -f "$mateterm_config"

            mate_get() {
                gsettings get org.mate.terminal.profile:/org/mate/terminal/profiles/"$1"/ "$2"
            }

            if [[ "$(mate_get "$profile" "use-system-font")" == "true" ]]; then
                font="$(gsettings get org.mate.interface monospace-font-name)"
            else
                font="$(mate_get "$profile" "font")"
            fi
            font="$(trim_quotes "$font")"
        fi
    ;;

    "mintty")
        font="$(awk -F '=' '!/^($|#)/ && /Font/ {printf $2; exit}' "${HOME}/.minttyrc")"
    ;;

    "pantheon"*)
        font="$(gsettings get org.pantheon.terminal.settings font)"

        [[ -z "${font//\'}" ]] && \
            font="$(gsettings get org.gnome.desktop.interface monospace-font-name)"

        font="$(trim_quotes "$font")"
    ;;

    "qterminal")
        font="$(awk -F '=' '/fontFamily=/ {a=$2} /fontSize=/ {b=$2} END {print a,b}' \
                        "$HOME/.config/qterminal.org/qterminal.ini")"
    ;;

    "sakura"*)
        font="$(awk -F '=' '/^font=/ {print $2; exit}' \
                        "$HOME/.config/sakura/sakura.conf")"
    ;;

    "st")
        font="$(ps -o command= -p "$parent" | grep -F -- "-f")"

        if [[ "$font" ]]; then
            font="${font/*-f/}"
            font="${font/ -*/}"

        else
            # On Linux we can get the exact path to the running binary through the procfs
            # (in case `st` is launched from outside of $PATH) on other systems we just
            # have to guess and assume `st` is invoked from somewhere in the users $PATH
            [[ -L "/proc/$parent/exe" ]] && binary="/proc/$parent/exe" || binary="$(type -p st)"

            # Grep the output of strings on the `st` binary for anything that looks vaguely
            # like a font definition. NOTE: There is a slight limitation in this approach.
            # Technically "Font Name" is a valid font. As it doesn't specify any font options
            # though it is hard to match it correctly amongst the rest of the noise.
            [[ -n "$binary" ]] &&
                font=$(
                    strings "$binary" |

                    grep -m 1 "*font[^2]"
                )
        fi

        font="${font/xft:}"
        font="${font#*=}"
        font="${font/:*}"
    ;;

    "terminology")
        font="$(strings "$HOME/.config/terminology/config/standard/base.cfg" |\
                        awk '/^font\.name$/{print a}{a=$0}')"
        font="${font/.pcf}"
        font="${font/:*}"
    ;;

    "termite")
        [[ -f "$HOME/.config/termite/config" ]] && \
            termite_config="$HOME/.config/termite/config"

        font="$(awk -F '= ' '/\[options\]/ {
                                        opt=1
                                    }
                                    /^\s*font/ {
                                        if(opt==1) a=$2;
                                        opt=0
                                    } END {print a}' "/etc/xdg/termite/config" \
                        "$termite_config")"
    ;;

    urxvt|urxvtd|rxvt-unicode|xterm)
        xrdb=$(xrdb -query)
        font=$(grep -im 1 -e "^${term/d}"'\**\.*font:' -e '^\*font:' <<< "$xrdb")
        font=${font/*"*font:"}
        font=${font/*".font:"}
        font=${font/*"*.font:"}
        font=$(trim "$font")

        [[ -z $font && $term == xterm ]] && \
            font=$(grep '^XTerm.vt100.faceName' <<< "$xrdb")

        font=$(trim "${font/*"faceName:"}")

        # xft: isn't required at the beginning so we prepend it if it's missing
        [[ ${font:0:1} != '-' && ${font:0:4} != xft: ]] && \
            font=xft:$font

        # Xresources has two different font formats, this checks which
        # one is in use and formats it accordingly.
        case $font in
            *xft:*)
                font=${font/xft:}
                font=${font/:*}
            ;;

            -*)
                IFS=- read -r _ _ font _ <<< "$font"
            ;;
        esac
    ;;

    "xfce4-terminal")
        font="$(awk -F '=' '/^FontName/{a=$2}/^FontUseSystem=TRUE/{a=$0} END {print a}' \
                        "$HOME/.config/xfce4/terminal/terminalrc")"

        [[ "$font" == "FontUseSystem=TRUE" ]] && \
            font="$(gsettings get org.gnome.desktop.interface monospace-font-name)"

        font="$(trim_quotes "$font")"

        # Default fallback font hardcoded in terminal-preferences.c
        [[ -z "$font" ]] && font="Monospace 12"
    ;;

    conemu-*)
        # Could have used `eval set -- "$ConEmuArgs"` instead for arg parsing.
        readarray -t ce_arg_list < <(xargs -n1 printf "%s\n" <<< "${ConEmuArgs-}")

        for ce_arg_idx in "${!ce_arg_list[@]}"; do
            # Search for "-LoadCfgFile" arg
            [[ "${ce_arg_list[$ce_arg_idx]}" == -LoadCfgFile ]] && {
                # Conf path is the next arg
                ce_conf=${ce_arg_list[++ce_arg_idx]}
                break
            }
        done

        # https://conemu.github.io/en/ConEmuXml.html#search-sequence
        for ce_conf in "$ce_conf" "${ConEmuDir-}\ConEmu.xml" "${ConEmuDir-}\.ConEmu.xml" \
                        "${ConEmuBaseDir-}\ConEmu.xml" "${ConEmuBaseDir-}\.ConEmu.xml" \
                        "$APPDATA\ConEmu.xml" "$APPDATA\.ConEmu.xml"; do
            # Search for first conf file available
            [[ -f "$ce_conf" ]] && {
                # Very basic XML parsing
                font="$(awk '/name="FontName"/ && match($0, /data="([^"]*)"/) {
                    print substr($0, RSTART+6, RLENGTH-7)}' "$ce_conf")"
                break
            }
        done

        # Null-terminated contents in /proc/registry files triggers a Bash warning.
        [[ "$font" ]] || read -r font < \
            /proc/registry/HKEY_CURRENT_USER/Software/ConEmu/.Vanilla/FontName
    ;;
    guake)
        font=$(dconf read /apps/guake/style/font/style | sed s/\'//g)
        if [ $(dconf read /apps/guake/general/use-default-font) == "true" ]; then
            font="$(gsettings get org.gnome.desktop.interface monospace-font-name)"
        fi
    ;;
esac
echo $font
